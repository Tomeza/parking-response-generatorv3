# 駐車場問い合わせ返信生成システム 現行要件定義書

## 1. 概要

### 1.1 システムの目的

本システムは、駐車場に関するユーザーからの自然言語による問い合わせに対し、構造化されたナレッジベースと高度な検索ロジックを用いて、迅速かつ最適な返信文案を生成・提供することを目的としたWebアプリケーションです。現在の実装は以下の特徴を持ちます:

-   ユーザーの問い合わせテキストに基づき、PGroongaを利用したPostgreSQLナレッジベースから関連性の高い情報を高速検索 (目標応答速度: 1秒以内)。
-   日本語形態素解析 (Kuromoji) を利用した検索キーワード抽出と精度向上。
-   回答生成プロセスにおける主要ステップ（キーワード抽出、ナレッジ検索、テンプレート適用、アラート付与）の可視化。
-   生成された返信文のコピー機能、メールクライアント連携機能。
-   管理画面を通じたナレッジベースのメンテナンス（追加、編集、削除）、応答ログの確認、フィードバック管理。
-   検索キャッシュによるパフォーマンス最適化とリセット機能。
-   Next.js App Router (React 18) を用いたサーバーサイドとクライアントサイドの効率的な統合。
-   Tailwind CSSによるレスポンシブデザインとダークモードUI。

### 1.2 前提条件

-   **ナレッジベース**: PostgreSQLデータベース（PGroonga拡張機能を利用）で管理されるナレッジデータ。
-   **ユーザー**: 主に単一管理者を想定 (認証はNextAuth.jsによる)。
-   **技術スタック (現行バージョン)**:
    -   フロントエンド: React (`18.2.0`), Next.js (`14.1.3` - App Router), TypeScript (`5.3.3`), Tailwind CSS (`3.3.0`)
-   **バックエンド**: Node.js (Next.jsサーバー), PostgreSQL (PGroonga / pgvector 拡張)
    -   データベースクライアント/ORM: Prisma (`6.4.1`), node-postgres (`pg` `8.13.3`)
    -   形態素解析: Kuromoji.js (`0.1.2`)
    -   認証: NextAuth.js (`4.24.11`)
    -   開発環境: Docker (`docker-compose.yml` による PostgreSQL/PGroonga 環境構築)
-   **開発フェーズ**: LINEボットやWebチャットボット展開の基盤となるWebアプリケーション。
   **戦略方針**: 現行システムを基盤としつつ、**ベクトル検索を段階導入（ハイブリッド検索）**し、将来的には**限定的なRAG機能**をAI清書ステップの拡張として導入する（軽い方向転換）。

## 2. 機能要件

### 2.1 メインダッシュボード (`/`)

#### 問い合わせ入力エリア

-   **要件**: ユーザーが問い合わせ文を入力できるテキストエリア。
-   **仕様**:
    -   入力上限: (指定があれば記載、現状はUI依存)
    -   プレースホルダー: 「問い合わせ内容を入力してください」
    -   入力内容に応じてリアルタイムに検索実行（デバウンス/スロットリングは要検討）
-   **実装**: 主にClient Componentで実装。

#### 回答生成プロセス表示

-   **概要**: 問い合わせから回答が生成されるまでの内部プロセスをステップごとに表示。
-   **ステップ1: キーワード抽出/前処理**:
    -   入力クエリからKuromojiを用いて形態素解析を実行。
    -   主要な品詞（名詞、動詞、形容詞、副詞）の基本形を抽出。
    -   抽出された検索タームを表示。
-   **ステップ2: ナレッジ検索（ハイブリッドアプローチ）**:
    -   **PGroonga検索**: 従来通り、抽出されたタームと元のクエリを用いてキーワードベースの全文検索を実行。
    -   **ベクトル検索 (pgvector)**: 問い合わせ文をベクトル化（例: Sentence-BERT）し、`Knowledge`テーブルに格納されたベクトルデータと類似度計算（コサイン類似度など）を行い、意味的に類似したナレッジを検索。
    -   **結果統合**: PGroongaのスコアとベクトル検索の類似度スコアを重み付けしてマージし、最終的なランキングを決定（例: `score = 0.6 * vector_score + 0.4 * pgroonga_score`）。
    -   検索結果（上位10件）を統合スコア順にソートして取得。
    -   ヒットしたナレッジのID、質問、スコア（統合スコア）を表示。ベストマッチ情報をハイライト。
    -   検索パフォーマンスメトリクス（処理時間など）も内部的に取得。
-   **ステップ3: テンプレート適用**:
    -   検索結果のベストマッチに基づき、適用するテンプレート（`Knowledge`テーブルの`answer`）を決定。
    -   特定条件（例: `note`フィールドの内容による外車/国際線関連）に基づき、専用テンプレートを適用する場合がある。
-   **ステップ4: アラート追加**:
    -   生成された回答文に対し、必須アラート（例: 「国際線利用不可」「外車受入不可」）を`addMandatoryAlerts`関数により付与。
    -   最終的な回答文を生成。
-   **実装**: 検索結果はAPI (`/api/query`) から取得し、Client Componentで各ステップの情報を表示。

#### 回答表示エリア

-   **要件**: 生成された最終的な返信文を表示し、活用できる機能を提供。
-   **仕様**:
    -   整形された最終返信文テキストを表示。
    -   「コピー」ボタン: 表示されている回答文をクリップボードにコピー (Clipboard API)。
    -   「メール送信」ボタン: `mailto:` スキームを利用してデフォルトのメールクライアントを起動し、回答文を本文に挿入。
-   **実装**: Client Componentで実装。

#### 履歴サイドバー (または類似のコンポーネント)

-   **要件**: 過去の問い合わせと回答結果の概要をリスト表示し、参照できる。
-   **仕様**:
    -   `SearchHistory` テーブルまたは `ResponseLog` テーブルから最近の検索履歴を取得。
    -   問い合わせ内容の概要や日時を表示。
    -   クリックで詳細（過去の応答など）を表示する機能（現状の実装レベルによる）。
-   **実装**: Server/Client Componentの組み合わせで実装。

#### 画面レイアウト

-   **配色**: ダークモードを基調 (例: 背景 `#1E1E1E`, 文字 `#FFFFFF`, ボタン `#0066FF`)。
-   **構造**: デスクトップでは左右ペイン分割、モバイルでは縦積みレイアウトを基本とするレスポンシブデザイン (Tailwind CSS)。

### 2.2 回答生成ロジック (`src/lib/search.ts`, `/api/query/route.ts`)

-   **入力**: ユーザーからの問い合わせ文字列 (`query`)、オプションでタグ文字列 (`tags`)。
-   **検索戦略**: **ハイブリッド検索**を採用。PGroongaによるキーワード検索と、`pgvector`を用いたベクトル検索（意味的類似性）を組み合わせ、両者のスコアを統合して最終的な検索結果を得る。
-   **処理フロー**:
    1.  **入力正規化**: クエリの前後の空白を除去。
    2.  **Kuromoji初期化**: Kuromoji.jsのTokenizerを非同期で初期化（初回のみ）。
    3.  **形態素解析**: Tokenizerを用いてクエリを解析し、主要品詞（名詞, 動詞, 形容詞, 副詞）の基本形を抽出・フィルタリング（1文字以下を除外）。
    4.  **ベクトル化**: 問い合わせ文を事前学習済みモデル（例: `sentence-transformers/all-mpnet-base-v2`）を用いてベクトルに変換。
    5.  **PGroonga検索実行**: 従来通りのPGroongaクエリを構築し実行。
    6.  **ベクトル検索実行**: 問い合わせベクトルと`Knowledge`テーブル内のベクトルデータ（`pgvector`拡張を利用）との類似度を計算し、類似度の高いナレッジを取得。
    7.  **スコア統合**: PGroongaのスコアとベクトル類似度スコアを重み付けして統合し、最終的なランキングを作成。
    8.  **結果整形**: 統合スコアに基づいてソートされた`SearchResult` 型の配列にマッピング。
    9.  **フォールバック**: KuromojiやPGroonga/ベクトル検索でエラーが発生した場合、シンプルな `contains` (ILIKE) 検索 (`simpleSearch` 関数) を実行。
    10. **アラート検出**: (現行の `query/route.ts` では検索前) 入力クエリに対して `detectAlertKeywords` を実行。
    11. **テンプレート選択と適用**: 統合スコアに基づいたベストマッチ (`searchResults[0]`) を基に回答文を決定。特定`note`を持つナレッジには専用回答を適用。
    12. **必須アラート付与**: `addMandatoryAlerts` を使用して最終回答文に固定アラートを追加。
    13. **ログ保存**: `ResponseLog` テーブルに検索クエリ、生成された回答、使用したナレッジIDなどを記録。
    14. **レスポンス生成**: 最終回答文、生成ステップ、使用ナレッジID、パフォーマンスメトリクスなどを含むJSONレスポンスを返す。
-   **キャッシュ**: 検索結果キャッシュ機構を利用。`/api/query?reset_cache=true` でキャッシュクリア可能。Embedding生成もキャッシュやバッチ処理を検討。
-   **Embedding生成**: ナレッジデータのベクトル化は、初期は夜間バッチ処理で行い、その後は**差分更新**（DBトリガーや定期ジョブ等で新規/更新データをベクトル化）を実装。運用安定後にオンデマンド生成（API呼び出し時）への移行も検討。

### 2.3 管理画面 (`/admin` 以下)

-   **認証**: NextAuth.jsによる認証保護。
-   **機能**: (APIエンドポイントから推測される機能)
    -   **回答生成記録 (`/api/admin/records`?)**: `ResponseLog` テーブルの内容を一覧表示、検索、フィルタリング。フィードバック状況の確認。
    -   **ナレッジ管理 (`/api/knowledge`?)**: `Knowledge` テーブルに対するCRUD操作。カテゴリ、タグ（`KnowledgeTag` 経由）の管理。
    -   **タグ管理 (`/api/tags`?)**: `Tag` テーブル、`TagSynonym` テーブルに対するCRUD操作。
    -   **アラートワード管理 (`/api/admin/alert-words`?)**: `AlertWord` テーブルに対するCRUD操作。
    -   **繁忙期管理 (`/api/admin/seasonal-info`?)**: `SeasonalInfo` テーブルに対するCRUD操作。日付範囲と説明を設定。
    -   **バックアップ/復元**: (当初要件にあったが、現行APIエンドポイントからは確認できず。実装状況要確認)
-   **実装**: Server ComponentとClient Componentを組み合わせ、各種APIエンドポイントと連携してデータを表示・操作。
-   **プロンプト (清書)**: ユーザー入力 (`original_response`) を基に、役割（駐車場の問い合わせ担当者）と指示（自然で丁寧な日本語への整形、情報追加/削除禁止）を与えたプロンプトを生成してAPIに送信。
-   **ハルシネーション対策 (清書)**: プロンプトによる制約（事実変更禁止、提供情報のみ使用）、グラウンディング（DB情報が主）、AIは清書に限定。
-   **RAG導入 (将来検討)**:
    -   **目的**: AI清書機能の拡張として、より文脈に即した高品質な応答生成を目指す。
    -   **アプローチ**: ハイブリッド検索結果の上位k件をコンテキスト情報としてLLM（例: Claude, GPT-4o）のプロンプトに含め、応答を生成させるシンプルなRAGをPoCで試行。
    -   **評価指標**: BLEUスコア (≥ 0.4目標)、応答時間 (≤ 1.5s目標)、CS評価 (A/Bテスト)。
    -   **導入判断**: PoCの結果と運用コスト（APIコスト、プロンプト管理、ハルシネーション対策）を考慮。Feature Flagによる制御を前提とする。
    -   **Agentic RAG**: より高度なクエリ分解やツール連携を伴うAgentic RAGは、問い合わせ量が大幅に増加し、FAQ拡充が追いつかない段階での検討課題とする（例: 1万件/月超）。

## 3. データベース構造 (`prisma/schema.prisma`)

※ 主要モデルのみ抜粋。詳細は `prisma/schema.prisma` を参照。

-   **`Knowledge`**: ナレッジの基本情報（カテゴリ、質問、回答、テンプレートフラグ、メモ等）を格納。PGroongaインデックスが付与されている。
-   **`Tag`**: タグ情報（タグ名、説明）。
-   **`KnowledgeTag`**: `Knowledge` と `Tag` の多対多関連テーブル。
-   **`AlertWord`**: 注意喚起が必要なキーワード（単語、説明、関連タグID、優先度）。
-   **`ResponseLog`**: 問い合わせと回答の履歴（クエリ、回答文、使用ナレッジID、フィードバック有無、関連Knowledge ID、ヒット件数等）。
-   **`SeasonalInfo`**: 繁忙期などの期間情報（情報タイプ、開始日、終了日、説明）。
-   **`FeedbackWeight`**: クエリパターンとナレッジIDに基づき、フィードバックによる重み付けを管理（利用状況は要確認）。
-   **`TagSynonym`**: タグの同義語。
-   **`SearchHistory`**: 検索クエリの履歴（クエリ、カテゴリ、タグ等）。
-   **`AdminUser`**: 管理画面用ユーザー情報（ユーザー名、パスワードハッシュ等）。
-   **`SearchSynonym`**: 検索用の同義語（`TagSynonym` との使い分け要確認）。
-   **`KnowledgeQuestionVariation`**: ナレッジに対する質問のバリエーション。

**インデックス**: PGroonga (`pgroonga`), GIN (`search_vector`), B-tree など、検索パフォーマンス向上のために複数のインデックスが定義されている。`pg_trgm` 拡張も利用。

## 4. AIモデル活用 (`/api/refine`)

-   **利用目的**: 主に検索結果から生成された回答文を、より自然で丁寧な日本語に「清書」するため。
-   **利用モデル**: Anthropic Claude 3 Sonnet (`claude-3-sonnet-20241022`) (バージョンは設定による)
-   **API連携**: `@anthropic-ai/sdk` を使用。
-   **プロンプト**: ユーザー入力 (`original_response`) を基に、役割（駐車場の問い合わせ担当者）と指示（自然で丁寧な日本語への整形、情報追加/削除禁止）を与えたプロンプトを生成してAPIに送信。
-   **ハルシネーション対策**: プロンプトによる制約（事実変更禁止、提供情報のみ使用）、グラウンディング（DB情報が主）、AIは清書に限定。

## 5. 技術スタック (詳細)

-   **Next.js**: 14.1.3 (App Router)
-   **React**: 18.2.0
-   **TypeScript**: 5.3.3
-   **Tailwind CSS**: 3.3.0
**PostgreSQL**  
 ├─ **PGroonga**（キーワード全文検索用拡張）  
 └─ **pgvector**（ベクトル検索用拡張）  
+ ※ ローカル Docker は開発時のみ。本番は Supabase のマネージド Postgres（上記両拡張を有効化）を使用。

-   **Prisma**: 6.4.1 (ORM, マイグレーション管理)
-   **node-postgres (pg)**: 8.13.3 (DBドライバ)
-   **Kuromoji.js**: 0.1.2 (形態素解析)
-   **NextAuth.js**: 4.24.11 (認証)
-   **@anthropic-ai/sdk**: 0.39.0 (AI連携)
-   **ESLint/Prettier**: コード整形・静的解析 (設定ファイル: `.eslintrc.json`, `eslint.config.mjs`)
-   **Docker**: 開発環境構築

## 6. 環境

### 6.1 開発環境

-   **基本方針 (推奨)**:
    -   **データベース**: 開発用のSupabaseプロジェクトまたはブランチにリモート接続 (`.env` または `.env.development` で接続情報を管理)。**Dockerは原則不要**。
    -   **実行**: `pnpm dev` または `vercel dev` でNext.js開発サーバーを起動。
    -   **メリット**: 環境構築が容易、Docker管理不要、常にリモートDBと同期。
    -   **代替方針 (オフライン/特定テスト時)**:
        -   **データベース**: `supabase start` コマンドでローカルマシン上にDockerコンテナ (PostgreSQL, Auth, Storage等) を起動 (`supabase start --no-backend` でPostgresのみ起動も可)。
        -   **実行**: 同様に `pnpm dev` または `vercel dev` で起動。ローカルDBコンテナに接続。
        -   **メリット**: オフライン開発可能、RLS/Edge Functions等のローカルテスト・デバッグが容易。
        -   **デメリット**: Docker環境が必要、リソース消費。
    -   **環境分離**: 開発用DBと本番DBは**必ず分離**する (個人開発のため **Supabase Branching機能** を利用予定)。

### 6.2 本番環境 (想定)

-   **アプリケーションホスティング**: **Vercel** を利用。Next.jsアプリケーションをビルドし、Serverless Functions / Edge Functionsとして自動デプロイ。**アプリケーション用Dockerコンテナは不要**。
-   **データベース**: **Supabase** のマネージドPostgreSQLを利用。本番用プロジェクトを使用し、`pgroonga` および `pgvector` 拡張機能を有効化。
-   **接続**: VercelからSupabaseへの接続は、接続プーラー (Supavisor) 経由のTLS接続文字列 (`pgbouncer=true`付き) をVercelの環境変数に設定して利用。
-   **環境変数**: 本番用の `DATABASE_URL`, `SUPABASE_URL`, `SUPABASE_ANON_KEY`, `ANTHROPIC_API_KEY`, `NEXTAUTH_SECRET`, `NEXTAUTH_URL` などをVercelの環境変数に設定。

## 7. 今後の実装課題・改善点

`docs/Search_Improvements_2025-0422.md` および現状分析、採用戦略に基づき、以下のロードマップで改善を進める。

*注: 各フェーズの期間は目安であり、ソロ開発の進捗に応じて変動する可能性があります。*

-   **Phase 0: Stabilize (〜1ヶ月)**
    -   **目的**: 現行システムのベースライン確立。
    -   **タスク**: 現行PGroonga検索の精度と応答時間 (QoS) を詳細に計測・可視化。E2Eテストスイートを整備・拡充。
    -   **成果物**: Prometheus/Grafana等による監視ダッシュボード、安定したテストスイート。
-   **Phase 1: Hybrid Retrieval (〜3ヶ月)**
    -   **目的**: ベクトル検索の導入とハイブリッド検索基盤の構築。
    -   **タスク**: PostgreSQLに `pgvector` 拡張を導入。`Knowledge` テーブルにベクトルカラム追加。Sentence-BERT等のモデルを選定し、ナレッジベクトル生成用の夜間バッチ処理を実装。`/api/query` (または新エンドポイント `/api/query2`) を改修し、PGroonga検索とベクトル検索を実行、スコアを統合（例: `0.6*vector + 0.4*pgroonga`）して結果を返すようにする。
    -   **成果物**: `pgvector`マイグレーションスクリプト、Embedding生成バッチ、ハイブリッド検索API。
-   **Phase 2: Light-RAG PoC (3週間)**
    -   **目的**: RAGによる応答品質向上の可能性を検証。
    -   **タスク**: 既存のAI清書API (`/api/refine`) の拡張または代替として、ハイブリッド検索結果の上位3件程度のナレッジをコンテキストとしてLLM (Claude/GPT-4o等) に渡し、応答を生成させる機能を開発（Feature Flag制御下）。BLEUスコア、応答時間、CS担当者による定性評価（A/Bテスト）で効果を測定。
    -   **成果物**: RAG機能プロトタイプ (Feature Flag付き)、評価レポート。
-   **Phase 3: Prod Roll-out & Security Hardening (1ヶ月)**
    -   **目的**: PoCで効果が確認された機能の本番展開とセキュリティ強化。
    -   **タスク**: RAG PoCが成功基準を満たした場合、Feature Flagを有効化し、`/api/query` (または `/api/refine`) を正式に切り替え。推奨されるセキュリティ強化策（Cloud WAF/Edge FunctionsでのTLS終端、RDS IAM認証等によるDB接続、PIIマスキングプロキシ導入）を実装・本番適用。
    -   **成果物**: 本番リリースノート、運用手順書(Runbook)、強化されたセキュリティ構成。

   **7.5 インフラ移行ロードマップ (Supabase)**:
       -   **Step 0 – スキーマ移行**: 開発用Supabaseプロジェクト/ブランチを作成し、`pgroonga`, `vector`拡張を有効化。Prismaマイグレーションを実行。
          * **マイグレーション手法**
            *デフォルト*（リモート DB 前提）:
            ```bash
            npx prisma db push        # スキーマ即反映
            npx prisma migrate diff   # 本番との差分確認
            ```
            *オフライン／ローカル Postgres がある場合*:
            `prisma migrate dev → prisma migrate deploy` も利用可。
       -   **Step 1 – Vercel 接続切替**: 開発/本番環境の `.env` / Vercel環境変数を更新し、Supabase DBに接続するように切り替え。データ移行 (`pg_dump`, `pg_restore`) を実施。
       -   **Step 2 – パフォーマンス検証 & インデックス再構築**: 負荷テスト (k6等) でパフォーマンスを検証。PGroongaインデックスの再構築を計画・実行（必要に応じてCompute Add-on利用、例: "Burst 2 vCPU" 推奨）。
       -   **Step 3 – 監視設定**: Supabaseログを外部監視ツール (Datadog, Grafana Loki等) に転送設定。

---

(旧) `docs/Search_Improvements_2025-0422.md` および現状分析に基づく課題:

-   **検索精度向上 (特定クエリへの対応強化)**: (Phase 1以降、ハイブリッド検索によって改善を図る)
    -   「送迎不要時のプラン」: 関連ナレッジの追加と、**ベクトル類似度**およびPGroongaスコア調整の両面からアプローチ。
    -   「繁忙期の利用制限/予約のコツ」: より直接的なナレッジの追加と、**ベクトル類似度**およびPGroongaスコア調整。
    -   「最寄り駅からの移動手段」: アクセス関連の**ベクトル表現**の改善と、PGroongaスコアリング細分化。
    -   その他、テストクエリで精度が低いケースの分析と改善（ハイブリッドスコアの重み調整含む）。
-   **ナレッジベース拡充**: (継続課題)
    -   不足している情報の網羅性向上。
    -   多様な言い回しに対応するための `KnowledgeQuestionVariation` の活用（ベクトル検索との相乗効果も期待）。
    -   `TagSynonym`, `SearchSynonym` の効果的な利用と整備。
-   **スコアリングロジック改善**: (Phase 1以降)
    -   **ハイブリッドスコアの重み付け調整**: PGroongaスコアとベクトル類似度スコアの最適なバランスを見つけるための継続的な調整。
    -   `FeedbackWeight` テーブルを活用したフィードバックループの実装・強化（ベクトル検索結果へのフィードバックも考慮）。
    -   `SearchResult` におけるスコア算出ロジックの透明性向上とデバッグ機能。
-   **UI/UX改善**: (継続課題)
    -   回答生成プロセスの可視化方法の改善（ハイブリッド検索の要素も表示）。
    -   管理画面の操作性向上（ナレッジベクトル管理機能？）。
    -   履歴機能の強化。
-   **テスト**: (継続課題)
    -   テストケースの網羅性向上（ベクトル検索特有のケースも追加）。
    -   E2Eテストの導入検討 (Phase 0)。
    -   パフォーマンステストの定期的な実施（ハイブリッド検索導入後）。
-   **AI清書機能 / RAG**: (Phase 2以降)
    -   RAG導入時のプロンプト最適化による精度向上。
    -   清書/RAG生成前後の差分表示機能。
    -   エラーハンドリングの強化。
-   **バックアップ/リストア機能**: 当初要件にあった機能の実装または現状確認（DBバックアップはSupabaseの自動バックアップ機能を利用）。
-   **RLS (Row Level Security)**: Supabase Authと連携し、PostgreSQLのRLSポリシーを設定してデータアクセス制御を強化。
   例:
   ```sql
   CREATE POLICY "user_rw"
   ON knowledge
   FOR ALL
   USING       (auth.uid() = owner_id)
   WITH CHECK  (auth.uid() = owner_id);
   ```

## 8. 非機能要件 (現状および目標)

-   **パフォーマンス**:
    -   検索API (`/api/query`) 平均応答時間: 500ms以内 (目標値、現状は `performance` メトリクスで計測)。
    -   ページ初期ロード時間: 2秒以内 (Next.jsの最適化機能活用)。
-   **保守性**:
    -   コンポーネント化されたフロントエンド (`src/components`)。
    -   型安全なコード (TypeScript)。
    -   Prismaによるスキーマ管理とマイグレーション。
    -   コード品質チェック (ESLint)。
-   **スケーラビリティ**:
    -   データベースコネクションプール (`pg`) の適切な設定。
    -   キャッシュ戦略 (APIレスポンスキャッシュ、検索結果キャッシュ)。
    -   サーバーレス環境 (Vercel等) での運用を想定。
-   **可用性**:
    -   適切なエラーハンドリングとログ記録 (`ResponseLog` およびコンソールログ)。
    -   データベースの冗長化（本番環境での設定）。

## 9. テスト (現状)

-   **検索ロジックテスト**:
    -   `src/scripts/simple-search-test.ts` (拡張され、複数カテゴリのテストクエリと結果検証ロジックを含む)。
    -   `tests/test-*.ts`, `*.cjs` (特定クエリタイプごとのテストスクリプト)。
    -   `run-search-tests.sh`: テスト実行用シェルスクリプト。
-   **単体テスト/統合テスト**: (現状のカバレッジは限定的、拡充が必要)
-   **E2Eテスト**: (未実装)
-   **品質チェック**: ESLintによる静的解析。

## 10. セキュリティ・その他

-   **認証**: NextAuth.jsによるセッションベース認証。管理画面へのアクセス制御。
-   **環境変数**: `DATABASE_URL`, `ANTHROPIC_API_KEY`, `NEXTAUTH_SECRET` などの機密情報は `.env` ファイル（Git管理外）または環境変数で管理（**DB接続情報はIAM認証への移行を推奨**）。
-   **セキュリティ強化策 (Phase 3で導入)**:
    -   **ネットワーク**: Cloud WAFやNext.js Edge Functions等でのTLS終端とアクセス制御。
   **DB パスワード管理**: Supabase の「Rotate Password」機能で自動ローテーションし、平文パスワードを長期保存しない。
-   **RLS (Row Level Security)**: Supabase Authと連携し、PostgreSQL の RLS ポリシーでデータアクセスを制御。
   例:
   ```sql
   CREATE POLICY "user_rw"
   ON knowledge
   FOR ALL
   USING       (auth.uid() = owner_id)
   WITH CHECK  (auth.uid() = owner_id);
   ```

## 11. その他の注意点

### 11.1 ローカル開発環境
*   **Docker不要（推奨）** — リモート Supabase Branch に直結
*   **Docker利用（フル）** — `supabase start` で完全オフライン開発

### 11.2 Docker依存性の変化
*   **本番 (Vercel)**: Docker コンテナ不要
*   **ローカル**: 上記 2 モードから選択

### 11.3 主な注意点
*   **DB 分離**: dev＝Branch、本番＝Main
*   **リソース制限**: 初回 pgroonga インデックス → Compute Add-on "Burst 2 vCPU" 推奨
*   **セキュリティ**: RLS、API キー、PII マスキング 